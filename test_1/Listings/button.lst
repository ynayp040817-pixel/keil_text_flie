C51 COMPILER V9.60.7.0   BUTTON                                                            02/13/2026 17:11:58 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE BUTTON
OBJECT MODULE PLACED IN .\Objects\button.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE button.c OPTIMIZE(8,SPEED) BROWSE INCDIR(C:\Keil_v5\C51\INC\STC) DEBUG O
                    -BJECTEXTEND PRINT(.\Listings\button.lst) TABS(2) OBJECT(.\Objects\button.obj)

line level    source

   1          #include <STC89C5xRC.H>
   2          
   3          // 矩阵键盘连接定义 (4x4矩阵键盘)
   4          // 行线连接P3.0-P3.3 (作为输出)
   5          // 列线连接P3.4-P3.7 (作为输入)
   6          sbit ROW0 = P3^0;  // 行0
   7          sbit ROW1 = P3^1;  // 行1
   8          sbit ROW2 = P3^2;  // 行2
   9          sbit ROW3 = P3^3;  // 行3
  10          sbit COL0 = P3^4;  // 列0
  11          sbit COL1 = P3^5;  // 列1
  12          sbit COL2 = P3^6;  // 列2
  13          sbit COL3 = P3^7;  // 列3
  14          
  15          // 延时函数
  16          void delay_ms(unsigned int ms)
  17          {
  18   1          unsigned int i, j;
  19   1          for(i = 0; i < ms; i++)
  20   1              for(j = 0; j < 114; j++);
  21   1      }
  22          
  23          // 矩阵键盘扫描函数
  24          // 返回按键值，0表示无按键，其他值表示按键编号
  25          unsigned char scan_key()
  26          {
  27   1          unsigned char row, col;
  28   1          
  29   1          // 设置列线为输入，行线为输出
  30   1          P3 = 0xF0;  // P3.4-P3.7设为输入(高电平)，P3.0-P3.3设为输出(低电平)
  31   1          
  32   1          // 检查是否有按键按下
  33   1          if((P3 & 0xF0) == 0xF0)  // 如果所有列线都是高电平，表示无按键
  34   1              return 0;
  35   1          
  36   1          // 逐行扫描
  37   1          for(row = 0; row < 4; row++)
  38   1          {
  39   2              // 设置所有行线为高电平
  40   2              P3 = 0xF0;
  41   2              
  42   2              // 逐行拉低，扫描该行
  43   2              switch(row)
  44   2              {
  45   3                  case 0: P3 = 0xFE; break;  // 11111110, 只有ROW0为低
  46   3                  case 1: P3 = 0xFD; break;  // 11111101, 只有ROW1为低
  47   3                  case 2: P3 = 0xFB; break;  // 11111011, 只有ROW2为低
  48   3                  case 3: P3 = 0xF7; break;  // 11110111, 只有ROW3为低
  49   3              }
  50   2              
  51   2              // 检查哪一列被拉低
  52   2              col = P3 & 0xF0;  // 读取列线状态
  53   2              
  54   2              switch(col)
C51 COMPILER V9.60.7.0   BUTTON                                                            02/13/2026 17:11:58 PAGE 2   

  55   2              {
  56   3                  case 0xE0:  // 11100000, COL0被拉低
  57   3                      return row * 4 + 1;  // 按键1, 5, 9, 13
  58   3                  case 0xD0:  // 11010000, COL1被拉低
  59   3                      return row * 4 + 2;  // 按键2, 6, 10, 14
  60   3                  case 0xB0:  // 10110000, COL2被拉低
  61   3                      return row * 4 + 3;  // 按键3, 7, 11, 15
  62   3                  case 0x70:  // 01110000, COL3被拉低
  63   3                      return row * 4 + 4;  // 按键4, 8, 12, 16
  64   3              }
  65   2          }
  66   1          
  67   1          return 0;  // 无按键按下
  68   1      }
  69          
  70          // 获取按键值（带去抖动）
  71          unsigned char get_key()
  72          {
  73   1          unsigned char key;
  74   1          
  75   1          key = scan_key();
  76   1          if(key != 0)  // 如果检测到按键
  77   1          {
  78   2              delay_ms(10);  // 延时去抖动
  79   2              if(scan_key() == key)  // 再次确认按键
  80   2                  return key;
  81   2          }
  82   1          return 0;  // 无按键或抖动
  83   1      }
  84          
  85          void main()
  86          {
  87   1          unsigned char key_value;
  88   1          
  89   1          // 初始化P3端口
  90   1          P3 = 0xFF;  // 设置为初始状态
  91   1          
  92   1          while(1)
  93   1          {
  94   2              key_value = get_key();
  95   2              
  96   2              if(key_value != 0)
  97   2              {
  98   3                  // 这里可以处理按键事件
  99   3                  // 例如：根据按键值执行不同操作
 100   3                  
 101   3                  // 简单演示：按键值显示在P1口LED上
 102   3                  P1 = ~key_value;  // 显示按键值到LED（反相显示）
 103   3                  
 104   3                  // 等待按键释放
 105   3                  while(get_key() != 0);
 106   3              }
 107   2              else
 108   2              {
 109   3                  P1 = 0xFF;  // 无按键时LED全灭
 110   3              }
 111   2          }
 112   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    200    ----
C51 COMPILER V9.60.7.0   BUTTON                                                            02/13/2026 17:11:58 PAGE 3   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
