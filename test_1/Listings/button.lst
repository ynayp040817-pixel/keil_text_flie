C51 COMPILER V9.60.7.0   BUTTON                                                            02/14/2026 13:30:54 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE BUTTON
OBJECT MODULE PLACED IN .\Objects\button.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE button.c OPTIMIZE(8,SPEED) BROWSE INCDIR(C:\Keil_v5\C51\INC\STC) DEBUG O
                    -BJECTEXTEND PRINT(.\Listings\button.lst) TABS(2) OBJECT(.\Objects\button.obj)

line level    source

   1          #include <STC89C5xRC.H>
   2          
   3          // 矩阵键盘连接定义 (4x4矩阵键盘)
   4          // 行线连接P3.0-P3.3 (作为输出)
   5          // 列线连接P3.4-P3.7 (作为输入)
   6          sbit ROW0 = P3^0;  // 行0
   7          sbit ROW1 = P3^1;  // 行1
   8          sbit ROW2 = P3^2;  // 行2
   9          sbit ROW3 = P3^3;  // 行3
  10          sbit COL0 = P3^4;  // 列0
  11          sbit COL1 = P3^5;  // 列1
  12          sbit COL2 = P3^6;  // 列2
  13          sbit COL3 = P3^7;  // 列3
  14          sbit sound = P2^3; //蜂鸣器
  15          // 延时函数
  16          void delay_ms(unsigned int ms)
  17          {
  18   1          unsigned int i, j;
  19   1          for(i = 0; i < ms; i++)
  20   1              for(j = 0; j < 114; j++);
  21   1      }
  22          
  23          // 矩阵键盘扫描函数（记忆优先级法）
  24          // 返回按键值，0表示无按键，其他值表示按键编号
  25          // 记忆第一次检测到的按键，直到所有按键释放后再重新检测
  26          unsigned char scan_key()
  27          {
  28   1          static unsigned char first_key_pressed = 0;  // 记忆第一个按键
  29   1          unsigned char row, col, temp_key;
  30   1          unsigned char current_scan_result = 0;
  31   1      
  32   1          // 设置列线为输入，行线为输出
  33   1          P3 = 0xF0;  // P3.4-P3.7设为输入(高电平)，P3.0-P3.3设为输出(低电平)
  34   1      
  35   1          // 检查是否有按键按下
  36   1          if((P3 & 0xF0) == 0xF0)  // 如果所有列线都是高电平，表示无按键
  37   1          {
  38   2              // 所有按键都释放了，重置记忆
  39   2              first_key_pressed = 0;
  40   2              return 0;
  41   2          }
  42   1      
  43   1          // 逐行扫描
  44   1          for(row = 0; row < 4; row++)
  45   1          {
  46   2              // 设置所有行线为高电平
  47   2              P3 = 0xF0;
  48   2      
  49   2              // 逐行拉低，扫描该行
  50   2              switch(row)
  51   2              {
  52   3                  case 0: P3 = 0xFE; break;  // 11111110, 只有ROW0为低
  53   3                  case 1: P3 = 0xFD; break;  // 11111101, 只有ROW1为低
  54   3                  case 2: P3 = 0xFB; break;  // 11111011, 只有ROW2为低
C51 COMPILER V9.60.7.0   BUTTON                                                            02/14/2026 13:30:54 PAGE 2   

  55   3                  case 3: P3 = 0xF7; break;  // 11110111, 只有ROW3为低
  56   3              }
  57   2      
  58   2              // 检查哪一列被拉低
  59   2              col = P3 & 0xF0;  // 读取列线状态
  60   2      
  61   2              if(col != 0xF0)  // 如果有列线被拉低
  62   2              {
  63   3                  switch(col)
  64   3                  {
  65   4                      case 0xE0:  // 11100000, COL0被拉低
  66   4                          temp_key = row * 4 + 1;  // 按键1, 5, 9, 13
  67   4                          break;
  68   4                      case 0xD0:  // 11010000, COL1被拉低
  69   4                          temp_key = row * 4 + 2;  // 按键2, 6, 10, 14
  70   4                          break;
  71   4                      case 0xB0:  // 10110000, COL2被拉低
  72   4                          temp_key = row * 4 + 3;  // 按键3, 7, 11, 15
  73   4                          break;
  74   4                      case 0x70:  // 01110000, COL3被拉低
  75   4                          temp_key = row * 4 + 4;  // 按键4, 8, 12, 16
  76   4                          break;
  77   4                      default:
  78   4                          temp_key = 0;
  79   4                          break;
  80   4                  }
  81   3                  
  82   3                  if(temp_key != 0)
  83   3                  {
  84   4                      current_scan_result = temp_key;
  85   4                      
  86   4                      // 如果还没有记录第一个按键，则记录它
  87   4                      if(first_key_pressed == 0)
  88   4                      {
  89   5                          first_key_pressed = temp_key;
  90   5                      }
  91   4                      
  92   4                      // 返回记忆的第一个按键，而不是当前扫描到的按键
  93   4                      return first_key_pressed;
  94   4                  }
  95   3              }
  96   2          }
  97   1      
  98   1          // 如果当前没有检测到按键但之前有按键被按下，返回记忆的按键
  99   1          if(first_key_pressed != 0)
 100   1          {
 101   2              return first_key_pressed;
 102   2          }
 103   1      
 104   1          return 0;  // 无按键按下
 105   1      }
 106          
 107          // 获取按键值（带去抖动）
 108          unsigned char get_key()
 109          {
 110   1          unsigned char key;
 111   1      
 112   1          key = scan_key();
 113   1          if(key != 0)  // 如果检测到按键
 114   1          {
 115   2              delay_ms(10);  // 延时去抖动
 116   2              if(scan_key() == key)  // 再次确认按键
C51 COMPILER V9.60.7.0   BUTTON                                                            02/14/2026 13:30:54 PAGE 3   

 117   2                  return key;
 118   2          }
 119   1          return 0;  // 无按键或抖动
 120   1      }
 121          
 122          void main()
 123          {
 124   1          unsigned char key_value;
 125   1      
 126   1          // 初始化P3端口
 127   1          P3 = 0xFF;  // 设置为初始状态
 128   1          P1 = 0xFF;  // 初始化P1端口，LED全灭
 129   1      
 130   1          while(1)
 131   1          {
 132   2              key_value = get_key();
 133   2      
 134   2              if(key_value != 0)
 135   2              {
 136   3                  // 这里可以处理按键事件
 137   3                  // 例如：根据按键值执行不同操作
 138   3      
 139   3                  // 简单演示：按键值显示在P1口LED上
 140   3                  P1 = ~key_value;  // 显示按键值到LED（反相显示）
 141   3                  sound = 0;
 142   3                  // 等待按键释放
 143   3                  while(get_key() != 0);
 144   3                  sound = 1;
 145   3              }
 146   2              else
 147   2              {
 148   3                  P1 = 0xFF;  // 无按键时LED全灭
 149   3              }
 150   2          }
 151   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    244    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
